<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>针体挠度交互仿真</title>
<style>
:root {
  color-scheme: light dark;
  --bg: #0f172a;
  --panel: #1e293b;
  --panel-light: #ffffff;
  --text: #e2e8f0;
  --accent: #38bdf8;
  --accent-strong: #0ea5e9;
  --danger: #f97316;
  --success: #22c55e;
  --border: rgba(255, 255, 255, 0.08);
  font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
}
@media (prefers-color-scheme: light) {
  :root {
    --bg: #f4f6fb;
    --panel: #ffffff;
    --panel-light: #ffffff;
    --text: #0f172a;
    --border: rgba(15, 23, 42, 0.08);
  }
}
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
.app {
  max-width: 1200px;
  margin: 0 auto;
  padding: 24px clamp(16px, 5vw, 32px) 40px;
}
header {
  margin-bottom: 24px;
}
header h1 {
  margin: 0 0 8px;
  font-size: clamp(1.6rem, 3vw, 2.2rem);
}
header p {
  margin: 0;
  opacity: 0.8;
}
.layout {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
}
.panel {
  background: var(--panel);
  border-radius: 20px;
  padding: 24px;
  border: 1px solid var(--border);
  box-shadow: 0 15px 35px rgba(15, 23, 42, 0.25);
}
.controls {
  flex: 1 1 320px;
}
.viewer {
  flex: 1 1 420px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}
.controls h2,
.viewer h2 {
  margin: 0 0 18px;
  font-size: 1.2rem;
}
.slider-grid {
  display: grid;
  gap: 18px;
}
.slider-group label {
  display: flex;
  justify-content: space-between;
  font-size: 0.95rem;
  margin-bottom: 6px;
  opacity: 0.9;
}
.slider-control {
  display: flex;
  align-items: center;
  gap: 10px;
}
.slider-control input[type="range"] {
  flex: 1;
  accent-color: var(--accent-strong);
}
.value-tag {
  min-width: 88px;
  text-align: right;
  font-variant-numeric: tabular-nums;
  font-size: 0.95rem;
}
.canvas-wrap {
  position: relative;
}
#needleCanvas {
  width: 100%;
  height: clamp(320px, 40vw, 460px);
  background: radial-gradient(circle at 30% 30%, rgba(56, 189, 248, 0.18), transparent 60%),
    #0b1120;
  border-radius: 18px;
  border: 1px solid var(--border);
  cursor: grab;
  display: block;
}
#needleCanvas:active {
  cursor: grabbing;
}
.overlay-hint {
  position: absolute;
  bottom: 14px;
  right: 18px;
  background: rgba(15, 23, 42, 0.6);
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 0.8rem;
  backdrop-filter: blur(6px);
}
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 12px;
}
.metric-card {
  background: rgba(15, 23, 42, 0.35);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 12px;
}
.metric-card p {
  margin: 0;
  font-size: 0.85rem;
  opacity: 0.8;
}
.metric-card strong {
  display: block;
  margin-top: 6px;
  font-size: 1.15rem;
  font-variant-numeric: tabular-nums;
  color: var(--accent);
}
.metric-card small {
  display: block;
  margin-top: 4px;
  font-size: 0.75rem;
  opacity: 0.7;
}
.status-text {
  margin: 4px 0 0;
  font-size: 0.9rem;
  font-variant-numeric: tabular-nums;
  transition: color 0.3s ease;
}
.status-text[data-state="ok"] {
  color: var(--success);
}
.status-text[data-state="warn"] {
  color: var(--danger);
}
@media (max-width: 768px) {
  .panel {
    padding: 18px;
  }
  .layout {
    flex-direction: column;
  }
}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>针体挠度交互仿真</h1>
    <p>通过拖动滑块实时计算针体尖端位移并在三维环境中观察挠度变化。</p>
  </header>

  <main class="layout">
    <section class="panel controls">
      <h2>载荷与几何参数</h2>
      <div class="slider-grid">
        <div class="slider-group">
          <label for="insertionLength">插入长度 (mm)<span>10–185</span></label>
          <div class="slider-control">
            <input type="range" id="insertionLength" min="10" max="185" step="1" value="150" data-unit="mm" data-precision="0" />
            <output id="insertionLengthValue" class="value-tag">150 mm</output>
          </div>
        </div>

        <div class="slider-group">
          <label for="Fx">Fx 轴向力 (N)</label>
          <div class="slider-control">
            <input type="range" id="Fx" min="-10" max="10" step="0.1" value="0" data-unit="N" data-precision="1" />
            <output id="FxValue" class="value-tag">0.0 N</output>
          </div>
        </div>

        <div class="slider-group">
          <label for="Fy">Fy 横向力 (N)</label>
          <div class="slider-control">
            <input type="range" id="Fy" min="-5" max="5" step="0.1" value="0" data-unit="N" data-precision="1" />
            <output id="FyValue" class="value-tag">0.0 N</output>
          </div>
        </div>

        <div class="slider-group">
          <label for="Fz">Fz 横向力 (N)</label>
          <div class="slider-control">
            <input type="range" id="Fz" min="-5" max="5" step="0.1" value="0" data-unit="N" data-precision="1" />
            <output id="FzValue" class="value-tag">0.0 N</output>
          </div>
        </div>

        <div class="slider-group">
          <label for="Mx">Mx 力矩 (N·m)</label>
          <div class="slider-control">
            <input type="range" id="Mx" min="-0.25" max="0.25" step="0.01" value="0" data-unit="N·m" data-precision="2" />
            <output id="MxValue" class="value-tag">0.00 N·m</output>
          </div>
        </div>

        <div class="slider-group">
          <label for="My">My 力矩 (N·m)</label>
          <div class="slider-control">
            <input type="range" id="My" min="-0.25" max="0.25" step="0.01" value="0" data-unit="N·m" data-precision="2" />
            <output id="MyValue" class="value-tag">0.00 N·m</output>
          </div>
        </div>

        <div class="slider-group">
          <label for="Mz">Mz 力矩 (N·m)</label>
          <div class="slider-control">
            <input type="range" id="Mz" min="-0.25" max="0.25" step="0.01" value="0" data-unit="N·m" data-precision="2" />
            <output id="MzValue" class="value-tag">0.00 N·m</output>
          </div>
        </div>
      </div>
    </section>

    <section class="panel viewer">
      <div class="canvas-wrap">
        <canvas id="needleCanvas" aria-label="三维针体可视化"></canvas>
        <div class="overlay-hint">拖动旋转，滚轮缩放</div>
      </div>

      <div class="metrics-grid">
        <div class="metric-card">
          <p>U<sub>x</sub></p>
          <strong id="uxValue">0.000 mm</strong>
          <small>轴向挠度</small>
        </div>
        <div class="metric-card">
          <p>U<sub>y</sub></p>
          <strong id="uyValue">0.000 mm</strong>
          <small>Y 方向位移</small>
        </div>
        <div class="metric-card">
          <p>U<sub>z</sub></p>
          <strong id="uzValue">0.000 mm</strong>
          <small>Z 方向位移</small>
        </div>
        <div class="metric-card">
          <p>θ<sub>y</sub></p>
          <strong id="thetaYValue">0.0000 rad</strong>
          <small>绕 Y 轴转角</small>
        </div>
        <div class="metric-card">
          <p>θ<sub>z</sub></p>
          <strong id="thetaZValue">0.0000 rad</strong>
          <small>绕 Z 轴转角</small>
        </div>
        <div class="metric-card">
          <p>Newton 状态</p>
          <strong id="iterationValue">–</strong>
          <small>迭代 / 残差</small>
        </div>
      </div>

      <p id="statusText" class="status-text">等待输入…</p>
    </section>
  </main>
</div>

<script>
class NeedleDeflectionModel {
  constructor() {
    this.needleDiameter = 1.27e-3;
    this.E = 200e9;
    this.G = 80e9;
    this.mu = 0.28;
    this.A = Math.PI * Math.pow(this.needleDiameter / 2, 2);
    this.I = Math.PI * Math.pow(this.needleDiameter, 4) / 64;
    this.J = 2 * this.I;

    this.H1 = [
      [12.0, -6.0, 0.0, 0.0],
      [-6.0, 4.0, 0.0, 0.0],
      [0.0, 0.0, 12.0, 6.0],
      [0.0, 0.0, 6.0, 4.0]
    ];
    this.H2 = [
      [-3.0 / 5, 1.0 / 20, 0.0, 0.0],
      [1.0 / 20, -1.0 / 15, 0.0, 0.0],
      [0.0, 0.0, -3.0 / 5, -1.0 / 20],
      [0.0, 0.0, -1.0 / 20, -1.0 / 15]
    ];
    this.H3 = [
      [0.0, 0.0, 0.0, -0.5],
      [0.0, 0.0, -0.5, -0.25],
      [0.0, -0.5, 0.0, 0.0],
      [-0.5, -0.25, 0.0, 0.0]
    ];
    this.H4 = [
      [1.0 / 700, -1.0 / 1400, 0.0, 0.0],
      [-1.0 / 1400, 11.0 / 6300, 0.0, 0.0],
      [0.0, 0.0, 1.0 / 700, 1.0 / 1400],
      [0.0, 0.0, 1.0 / 1400, 11.0 / 6300]
    ];
    this.H5 = [
      [0.0, 0.0, 0.0, 1.0 / 60],
      [0.0, 0.0, 1.0 / 60, 0.0],
      [0.0, 1.0 / 60, 0.0, 0.0],
      [1.0 / 60, 0.0, 0.0, 0.0]
    ];
    this.H6 = [
      [1.0 / 5, -1.0 / 10, 0.0, 0.0],
      [-1.0 / 10, 1.0 / 20, 0.0, 0.0],
      [0.0, 0.0, 1.0 / 5, 1.0 / 10],
      [0.0, 0.0, 1.0 / 10, 1.0 / 20]
    ];
    this.H7 = [
      [0.0, 0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0, 1.0],
      [0.0, 0.0, 0.0, 0.0],
      [0.0, 0.0, 0.0, 0.0]
    ];
  }

  normalizeParameters(Fx, Fy, Fz, Mx, My, Mz, L, n = 1) {
    const denom = this.E * this.I;
    const L2 = L * L;
    return {
      f_x: (Fx * L2) / (n * n * denom),
      f_y: (Fy * L2) / (n * n * denom),
      f_z: (Fz * L2) / (n * n * denom),
      m_x: (Mx * L) / (n * denom),
      m_y: (My * L) / (n * denom),
      m_z: (Mz * L) / (n * denom)
    };
  }

  denormalizeDisplacement(u_y, theta_z, u_z, theta_y, L, n = 1) {
    return {
      U_y: (u_y * L) / n,
      Theta_z: theta_z,
      U_z: (u_z * L) / n,
      Theta_y: theta_y
    };
  }

  calculateResidual(v, params) {
    const { f_x, f_y, f_z, m_x, m_y, m_z } = params;
    const [u_y, theta_z, u_z, theta_y] = v;
    const m_xd = m_x + theta_z * m_y + theta_y * m_z;
    const g = [f_y, m_z, f_z, m_y];

    const term1 = matVec(this.H1, v);
    const term2Matrix = matAdd(
      matScale(this.H2, 2 * f_x),
      matScale(matAdd(matScale(this.H3, 2), this.H7), m_xd)
    );
    const term3Matrix = matAdd(
      matAdd(matScale(this.H4, f_x * f_x), matScale(this.H5, m_xd * f_z)),
      matScale(this.H6, m_xd * m_xd)
    );
    const term2 = matVec(term2Matrix, v);
    const term3 = matVec(term3Matrix, v);

    return g.map((val, idx) => val - (term1[idx] - term2[idx] - term3[idx]));
  }

  calculateJacobian(v, params) {
    const { f_x, f_z, m_x, m_y, m_z } = params;
    const [, theta_z, , theta_y] = v;
    const m_xd = m_x + theta_z * m_y + theta_y * m_z;

    let J = matScale(this.H1, -1);
    J = matAdd(J, matScale(this.H2, 2 * f_x));
    const baseLinear = matAdd(matScale(this.H3, 2), this.H7);
    J = matAdd(J, matScale(baseLinear, m_xd));
    J = matAdd(J, matScale(this.H4, f_x * f_x));
    J = matAdd(J, matScale(this.H5, m_xd * f_z));
    J = matAdd(J, matScale(this.H6, m_xd * m_xd));

    const dm_xd_dv = [0, m_y, 0, m_z];
    const termLinear = matVec(baseLinear, v);
    const termQuadratic = matVec(
      matAdd(matScale(this.H5, f_z), matScale(this.H6, 2 * m_xd)),
      v
    );

    J = matAdd(J, outer(termLinear, dm_xd_dv));
    J = matAdd(J, outer(termQuadratic, dm_xd_dv));
    return J;
  }

  calculateTipDeflection(Fx, Fy, Fz, Mx, My, Mz, L) {
    const safeL = Math.max(L, 1e-6);
    const normParams = this.normalizeParameters(Fx, Fy, Fz, Mx, My, Mz, safeL);
    const g = [normParams.f_y, normParams.m_z, normParams.f_z, normParams.m_y];

    let vLinear = solveLinearSystem(this.H1, g);
    if (!vLinear) {
      vLinear = [0.001, 0.001, 0.001, 0.001];
    }
    let v = vLinear.map((val) => val * 0.5);

    const maxIterations = 20;
    const tolerance = 1e-8;
    let residualNorm = Number.POSITIVE_INFINITY;
    let iterations = 0;

    for (let i = 0; i < maxIterations; i++) {
      const Fv = this.calculateResidual(v, normParams);
      residualNorm = vectorNorm(Fv);
      iterations = i + 1;
      if (residualNorm < tolerance) break;

      const J = this.calculateJacobian(v, normParams);
      const rhs = Fv.map((val) => -val);
      let delta = solveLinearSystem(J, rhs);
      if (!delta) {
        delta = leastSquaresSolve(J, rhs);
      }
      if (!delta || delta.some((val) => !isFinite(val))) {
        delta = [0, 0, 0, 0];
      }
      const updateNorm = vectorNorm(delta);
      const scaledDelta = updateNorm > 10 ? vectorScale(delta, 0.5) : delta;
      v = vectorAdd(v, scaledDelta);
      if (v.some((val) => !isFinite(val))) {
        v = [0.0001, 0.0001, 0.0001, 0.0001];
        break;
      }
    }

    const denorm = this.denormalizeDisplacement(v[0], v[1], v[2], v[3], safeL);
    const U_x = (Fx * safeL) / (this.E * this.A);

    return {
      U_x,
      U_y: denorm.U_y,
      U_z: denorm.U_z,
      Theta_y: denorm.Theta_y,
      Theta_z: denorm.Theta_z,
      iterations,
      residual: residualNorm,
      converged: residualNorm < tolerance
    };
  }
}

/* ---------- 线性代数辅助函数 ---------- */
function matVec(A, v) {
  return A.map((row) => row.reduce((sum, val, idx) => sum + val * v[idx], 0));
}

function matScale(A, scalar) {
  return A.map((row) => row.map((val) => val * scalar));
}

function matAdd(A, B) {
  return A.map((row, i) => row.map((val, j) => val + B[i][j]));
}

function outer(a, b) {
  return a.map((ai) => b.map((bj) => ai * bj));
}

function vectorAdd(a, b) {
  return a.map((val, idx) => val + b[idx]);
}

function vectorScale(v, scalar) {
  return v.map((val) => val * scalar);
}

function vectorNorm(v) {
  return Math.sqrt(v.reduce((sum, val) => sum + val * val, 0));
}

function matTranspose(A) {
  return A[0].map((_, col) => A.map((row) => row[col]));
}

function matMul(A, B) {
  const rows = A.length;
  const cols = B[0].length;
  const shared = B.length;
  const result = Array.from({ length: rows }, () => Array(cols).fill(0));
  for (let i = 0; i < rows; i++) {
    for (let k = 0; k < shared; k++) {
      for (let j = 0; j < cols; j++) {
        result[i][j] += A[i][k] * B[k][j];
      }
    }
  }
  return result;
}

function solveLinearSystem(A, b) {
  const n = A.length;
  const M = A.map((row, i) => [...row, b[i]]);
  for (let i = 0; i < n; i++) {
    let pivot = i;
    for (let r = i + 1; r < n; r++) {
      if (Math.abs(M[r][i]) > Math.abs(M[pivot][i])) pivot = r;
    }
    if (Math.abs(M[pivot][i]) < 1e-12) {
      return null;
    }
    if (pivot !== i) {
      [M[i], M[pivot]] = [M[pivot], M[i]];
    }
    const pivotVal = M[i][i];
    for (let j = i; j <= n; j++) {
      M[i][j] /= pivotVal;
    }
    for (let r = 0; r < n; r++) {
      if (r === i) continue;
      const factor = M[r][i];
      for (let j = i; j <= n; j++) {
        M[r][j] -= factor * M[i][j];
      }
    }
  }
  return M.map((row) => row[n]);
}

function leastSquaresSolve(A, b) {
  const At = matTranspose(A);
  const AtA = matMul(At, A);
  const Atb = matVec(At, b);
  for (let i = 0; i < AtA.length; i++) {
    AtA[i][i] += 1e-9;
  }
  return solveLinearSystem(AtA, Atb);
}

/* ---------- UI 与可视化 ---------- */
const model = new NeedleDeflectionModel();
const sliderInputs = document.querySelectorAll('.slider-group input[type="range"]');
const metricEls = {
  ux: document.getElementById('uxValue'),
  uy: document.getElementById('uyValue'),
  uz: document.getElementById('uzValue'),
  thetaY: document.getElementById('thetaYValue'),
  thetaZ: document.getElementById('thetaZValue'),
  iteration: document.getElementById('iterationValue'),
  status: document.getElementById('statusText')
};

sliderInputs.forEach((input) => {
  updateSliderOutput(input);
  input.addEventListener('input', () => {
    updateSliderOutput(input);
    updateModel();
  });
});

function updateSliderOutput(input) {
  const unit = input.dataset.unit || '';
  const precision = Number(input.dataset.precision ?? 0);
  const value = Number(input.value).toFixed(precision);
  const output = document.getElementById(`${input.id}Value`);
  if (output) {
    output.textContent = `${value} ${unit}`.trim();
  }
}

function readParams() {
  return {
    L: Number(document.getElementById('insertionLength').value) / 1000,
    Fx: Number(document.getElementById('Fx').value),
    Fy: Number(document.getElementById('Fy').value),
    Fz: Number(document.getElementById('Fz').value),
    Mx: Number(document.getElementById('Mx').value),
    My: Number(document.getElementById('My').value),
    Mz: Number(document.getElementById('Mz').value)
  };
}

function updateModel() {
  const params = readParams();
  try {
    const result = model.calculateTipDeflection(
      params.Fx,
      params.Fy,
      params.Fz,
      params.Mx,
      params.My,
      params.Mz,
      params.L
    );
    updateMetrics(result);
    updateVisualization(result, params.L);
  } catch (err) {
    metricEls.status.textContent = `⚠️ 数值计算失败：${err.message}`;
    metricEls.status.dataset.state = 'warn';
  }
}

function updateMetrics(result) {
  metricEls.ux.textContent = `${(result.U_x * 1000).toFixed(3)} mm`;
  metricEls.uy.textContent = `${(result.U_y * 1000).toFixed(3)} mm`;
  metricEls.uz.textContent = `${(result.U_z * 1000).toFixed(3)} mm`;
  metricEls.thetaY.textContent = `${result.Theta_y.toFixed(4)} rad`;
  metricEls.thetaZ.textContent = `${result.Theta_z.toFixed(4)} rad`;
  metricEls.iteration.textContent = `${result.iterations} / ${result.residual.toExponential(2)}`;
  metricEls.status.textContent = result.converged
    ? `✅ 已收敛：||F|| = ${result.residual.toExponential(2)}`
    : `⚠️ 未完全收敛：||F|| = ${result.residual.toExponential(2)}`;
  metricEls.status.dataset.state = result.converged ? 'ok' : 'warn';
}

/* ---------- 三维绘制 ---------- */
const canvas = document.getElementById('needleCanvas');
const ctx = canvas.getContext('2d');
const camera = {
  yaw: 0.6,
  pitch: -0.2,
  distance: 0.45,
  fov: 0.8
};
let sceneData = { points: [], baseline: [], reference: 0.2 };
let isDragging = false;
let lastPointer = { x: 0, y: 0 };

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
  }
}

if ('ResizeObserver' in window) {
  const observer = new ResizeObserver(() => {
    resizeCanvas();
    renderScene();
  });
  observer.observe(canvas);
} else {
  window.addEventListener('resize', () => {
    resizeCanvas();
    renderScene();
  });
}

canvas.addEventListener('pointerdown', (e) => {
  isDragging = true;
  lastPointer = { x: e.clientX, y: e.clientY };
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - lastPointer.x;
  const dy = e.clientY - lastPointer.y;
  lastPointer = { x: e.clientX, y: e.clientY };
  camera.yaw += dx * 0.005;
  camera.pitch = clamp(camera.pitch + dy * 0.005, -1.3, 1.3);
  renderScene();
});
canvas.addEventListener('pointerup', (e) => {
  isDragging = false;
  canvas.releasePointerCapture(e.pointerId);
});
canvas.addEventListener('pointerleave', () => {
  isDragging = false;
});
canvas.addEventListener(
  'wheel',
  (e) => {
    e.preventDefault();
    camera.distance = clamp(camera.distance + e.deltaY * 0.0005, 0.18, 1.2);
    renderScene();
  },
  { passive: false }
);

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function updateVisualization(result, L) {
  const segments = 80;
  const geometry = computeNeedleGeometry(L, result, segments);
  sceneData = {
    points: geometry.points,
    baseline: geometry.baseline,
    reference: geometry.reference
  };
  renderScene();
}

function computeNeedleGeometry(L, deflection, segments = 80) {
  const safeL = Math.max(L, 1e-6);
  const points = [];
  const baseline = [];
  for (let i = 0; i <= segments; i++) {
    const s = (L * i) / segments;
    const t = s / safeL;
    const y = cubicHermite(t, deflection.U_y, 0, deflection.Theta_z, safeL);
    const z = cubicHermite(t, deflection.U_z, 0, -deflection.Theta_y, safeL);
    const x = s + deflection.U_x * t;
    points.push([x, y, z]);
    baseline.push([s, 0, 0]);
  }
  const reference = Math.max(
    safeL + Math.abs(deflection.U_x),
    Math.sqrt(deflection.U_y ** 2 + deflection.U_z ** 2) + safeL
  );
  return { points, baseline, reference };
}

function cubicHermite(t, endValue, startSlope, endSlope, L) {
  const t2 = t * t;
  const t3 = t2 * t;
  const h00 = 2 * t3 - 3 * t2 + 1;
  const h10 = t3 - 2 * t2 + t;
  const h01 = -2 * t3 + 3 * t2;
  const h11 = t3 - t2;
  return h00 * 0 + h10 * (startSlope * L) + h01 * endValue + h11 * (endSlope * L);
}

function renderScene() {
  resizeCanvas();
  ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  if (!sceneData.points.length) return;

  const scale = (Math.min(canvas.clientWidth, canvas.clientHeight) * 0.45) / sceneData.reference;

  drawAxes(scale);
  drawPolyline(sceneData.baseline, scale, '#64748b', 1, [6, 6]);
  drawPolyline(sceneData.points, scale, '#38bdf8', 3);
}

function rotatePoint(point) {
  const [x, y, z] = point;
  const cosYaw = Math.cos(camera.yaw);
  const sinYaw = Math.sin(camera.yaw);
  const cosPitch = Math.cos(camera.pitch);
  const sinPitch = Math.sin(camera.pitch);

  const x1 = x * cosYaw - z * sinYaw;
  const z1 = x * sinYaw + z * cosYaw;
  const y2 = y * cosPitch - z1 * sinPitch;
  const z2 = y * sinPitch + z1 * cosPitch;
  return [x1, y2, z2];
}

function projectPoint(point, scale) {
  const rotated = rotatePoint(point);
  const zCam = camera.distance - rotated[2];
  if (zCam <= 0.02) return null;
  const perspective = camera.fov / zCam;
  const px = canvas.clientWidth / 2 + rotated[0] * scale * perspective;
  const py = canvas.clientHeight / 2 - rotated[1] * scale * perspective;
  return { x: px, y: py };
}

function drawPolyline(points, scale, color, width = 2, dash = null) {
  ctx.save();
  ctx.lineWidth = width;
  ctx.strokeStyle = color;
  if (dash) ctx.setLineDash(dash);
  ctx.beginPath();
  let started = false;
  points.forEach((pt) => {
    const projected = projectPoint(pt, scale);
    if (!projected) return;
    if (!started) {
      ctx.moveTo(projected.x, projected.y);
      started = true;
    } else {
      ctx.lineTo(projected.x, projected.y);
    }
  });
  ctx.stroke();
  ctx.restore();
}

function drawAxes(scale) {
  const axisLen = sceneData.reference * 0.5;
  const axes = [
    { points: [[0, 0, 0], [axisLen, 0, 0]], color: '#fb7185', label: 'X' },
    { points: [[0, 0, 0], [0, axisLen, 0]], color: '#34d399', label: 'Y' },
    { points: [[0, 0, 0], [0, 0, axisLen]], color: '#fbbf24', label: 'Z' }
  ];
  axes.forEach((axis) => {
    drawPolyline(axis.points, scale, axis.color, 2);
    const labelPoint = projectPoint(axis.points[1], scale);
    if (labelPoint) {
      ctx.save();
      ctx.fillStyle = axis.color;
      ctx.font = '12px sans-serif';
      ctx.fillText(axis.label, labelPoint.x + 4, labelPoint.y - 4);
      ctx.restore();
    }
  });
}

/* ---------- 初始化 ---------- */
updateModel();
renderScene();
</script>
</body>
</html>